# 聚簇索引和非聚簇索引

1. 聚簇索引就是规定了数据的物理存储顺序，而非聚簇索引则没有规定数据的存储顺序。一个表只能有一个聚簇索引, 因为一个表只有一个物理顺序结构.
2. 聚簇索引的叶子节点存储的是整行数据，而非聚簇索引的叶子节点存储的是非聚簇的索引字段的值和索引字段的指针.
3. 非聚簇索引又叫二次索引, 因为要回表.

举个例子, 某个用户表id是唯一的, 那么会选择id作为聚簇索引. 又假设这个聚簇索引用的是B+树结构(默认一般为b+tree), 那么这个表的物理结构就是一个以iD为聚簇索引构建的B+树, 叶子节点存储的是整行数据.
相应的, 非聚簇索引, 例如用户表的name字段, 那么会建立一个新的b+tree表, 叶子节点存储的是name字段的值和用户的id(聚簇索引的值). 拿到对应的id还要去聚簇索引中查找对应的数据.

非聚簇索引读取后, 还需要再次查询聚簇索引拿到相应的数据的过程, 叫做**回表**

## MySQL

MySQL默认的InnoDB引擎会把主键作为聚簇索引.

* 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
* 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
* 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

mysql采用上述举例方式

## PostgreSQL

PG没有聚簇索引, 这是因为PostgreSQL 默认情况下使用堆表来存储数据。这意味着数据行在插入时存储在表的下一个可用位置，没有特定的物理顺序。PostgreSQL 支持通过 `CLUSTER` 命令手动对表进行聚簇。聚簇操作将表的数据重新排序，使其按指定的索引键顺序存储。这种操作会将数据物理顺序与指定的索引键对齐，但这种排序不会自动维护，数据插入或更新后需要重新聚簇以保持顺序。

pg的索引都是单独再建立的二次索引表.

举个例子:

```sql
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    name VARCHAR(50),
    position VARCHAR(50)
);

-- 创建一个B-Tree索引
CREATE INDEX idx_employee_name ON employees (name);
```

在这个例子中，B-Tree 索引 idx_employee_name 的叶子节点存储的内容如下：

* 索引键：name 列的值。
* 行位置标识符：指向数据行在堆表中的位置（CTID）。

## 引申个问题, pg为什么采用btree而不是b+tree呢?

### B-Tree 和 B+ Tree 的区别

#### B-Tree

* 每个节点都存储索引键和值（数据行或指针）。
* 内部节点和叶子节点都可以包含实际数据。
* 树的高度较低，但查找路径可能较长。

#### B+ Tree

* 只有叶子节点存储实际数据（或指向数据的指针），内部节点只存储索引键用于导航。
* 叶子节点通过双向链表链接，使得范围查询和顺序访问非常高效。
* 通常树的高度较高，但查找路径较短。

### PostgreSQL 的 B-Tree 实现

PostgreSQL 的 B-Tree 实现实际上结合了 B+ 树的许多特点，主要用于优化查找和范围查询的性能：

#### 叶子节点存储指针

* PostgreSQL 的 B-Tree 索引在叶子节点只存储索引键和指向实际数据行的指针（CTID），而不直接存储数据行。
* 这种设计类似于 B+ 树，优化了索引查找的性能。

#### 内部节点用于导航

* 内部节点只存储索引键用于导航，不存储实际数据行。
* 这使得树的高度较低，提高了查找效率。

#### 双向链表链接

* 叶子节点通过双向链表链接，支持高效的范围查询和顺序扫描。
* 这种结构使得 B-Tree 的范围查询性能类似于 B+ 树。

## 为什么不干脆叫pg的索引为b+tree

* PostgreSQL 的 B-Tree 实现结合了 B+ 树的许多特点，但仍然保留了一些 B-Tree 的特性。