# greenplum 事务

## 缓冲区buffer pool

Greenplum使用了PostgreSQL的缓冲区管理机制，即buffer pool。buffer pool是一个内存区域，用于存储磁盘上的数据块。buffer pool的大小是可以配置的，通常是数据库实例内存的一部分。buffer pool的大小对数据库性能有很大的影响，如果buffer pool太小，数据库将频繁地从磁盘读取数据块，从而降低性能。如果buffer pool太大，将占用过多的内存，导致操作系统频繁地进行内存交换，从而降低性能。

buffer pool内部是一个一个的block, 每个block又分为很多page. 因为数据库就是以page为单位进行i/o的.

不管greenPlum, PostgreSQL, MySQL, Oracle都是采用buffer pool的方式进行缓冲区管理.

## Write-Ahead Logging" (WAL) 策略

在数据库中, 关于事务和buffer pool, 有四种写入策略需要考虑:

1. force/no-force:

* force: 事务提交时, 所修改的页面必须强制写入到磁盘
* no-force: 事务提交时, 所修改的页面不一定要写入到磁盘

2.steal/no-steal:

* steal:  允许buffer pool里未提交事务所修改的脏页刷回到持久存储
* no-steal: 不允许buffer pool里未提交事务所修改的脏页刷回到持久存储

**force策略**对持久存储器进行频繁地随机写, 性能会下降.
**no-steal策略**, 如果一个事务修改了大部分的数据, 把buffer pool占满了, 其他事务就没办法申请到空间, 导致并发量不高.

所以一般数据库都采用No-force/steal策略, 有良好性能. 这种先将事务的数据写入日志文件, 再写入磁盘的方式叫做Write Ahead Logging(WAL)策略, 这里的WAL策略区分postgresql的WAL日志, 两者不同.
但是如何保证原子性和持久性呢? 因为no-force突然断电, 就会丢失数据, steal策略写入到磁盘中, 但是想回滚却断电, 就导致脏数据.

### 方法一: redo/undo 日志

引入日志:

* No-force -> redo log : 事务提交时，数据页不需要刷回持久存储，为了保证持久性，先把Redo Log写入日志文件。Redo log记录修改数据对象的新值(AfterImage,AFIM)
* steal -> undo log: 允许Buffer Pool未提交事务所修改的脏页刷回到持久存储，为了保证原子性先把Undo Log写入日志文件。UndoLog记录修改数据对象的旧值(Beforelmage, BFIM)

**缓冲区管理策略和事务恢复的关系:**

![93](/Image/database/93.png)

### WAL日志

1. 任何page在写入磁盘之前, 必须先保证log先写入磁盘:
   * steal policy政策, 记录undo log, 保证原子性
2. 在确保事务对数据修改的log在写入磁盘之后, 才能提交事务
    * no-force policy, 记录redo log, 保证持久性

## mySQL vs PostgreSQL

mySQL采用 redo + undo. 而postgres只有WAL.

redo的操作, 也就是把事务的数据先提交给日志而不是写入磁盘的操作, mysql和postgres差不多, 都是先写入redo日志或WAL日志.

但是undo做操不同, 两者虽然都是借助MVCC来进行版本控制, 但是mysql表中只有一行数据, 表中通常只有当前版本的数据行，历史版本通过 undo 日志记录。在读取旧版本时，利用 undo 日志恢复出需要的历史数据。而PostgreSQL: 直接在表中存储多个物理版本的数据行，每个版本行包含创建和删除该版本的事务 ID。旧版本数据会在不需要时被 VACUUM 清理。读取时候, PostgreSQL: 读取数据时，通过检查数据行的事务 ID 来选择合适的版本。
MySQL (InnoDB): 读取数据时，如果需要历史版本，会通过 undo 日志恢复出旧版本的数据。

## greenplum采用的buffer pool策略

steal + no-force + redo log, 没有undo log.
这是因为greenplum采用heap表, 更新操作不是in place, 而是重新创建新的tuple, 可以通过事务可见性判断对某个事物可见与否.

分布式事务是典型的嵌套式事务, 一个事务由多个工作节点的子事务构成, 要么全部提交要么全部回滚. 如果只有一个阶段提交事务, 比如master提交事务, 下面的机器可能有些提交有些失败. 所以gp采用两阶段提交协议:

![94](/Image/database/94.png)
![94](/Image/database/95.png)

第一次发送prepare, 只有当收到集群返回的ack, 才会发送commit. 如果有一个节点失败, 就会回滚.