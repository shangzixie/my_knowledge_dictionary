# 向量数据库向量检索算法

## 最近邻搜索

在保存向量数据后，先对向量数据先进行聚类。

### k-Means

![110](/Image/database/110.png)

1. 选择 k 个初始聚类中心。
2. 将每个数据点分配到最近的聚类中心。
3. 计算每个聚类的新中心。
4. 重复步骤 2 和 3，直到聚类中心不再改变或达到最大迭代次数。

但是这种搜索方式也有一些缺点，例如在搜索的时候，如果搜索的内容正好处于两个分类区域的中间，就很有可能遗漏掉最相似的向量。

### Faiss

我们可以将向量想象为包含在 Voronoi 单元格中 - 当引入一个新的查询向量时，首先测量其与质心 (centroids) 之间的距离，然后将搜索范围限制在该质心所在的单元格内. 那么为了解决搜索时可能存在的遗漏问题，可以将搜索范围动态调整，例如当 nprobe = 1 时，只搜索最近的一个聚类中心，当 nprobe = 2 时，搜索最近的两个聚类中心，根据实际业务的需求调整 nprobe 的值。

![110](/Image/database/111.png)

### Product Quantization 乘积量化

![112](/Image/database/112.png)

在大规模数据集中，聚类算法最大的问题在于内存占用太大。因为需要保存每个向量的坐标，而每个坐标都是一个浮点数，占用的空间就已经非常大了。还需要维护聚类中心和每个向量的聚类中心索引，这也会占用大量的空间.

对于第一个问题，可以通过量化 (Quantization) 的方式解决，也就是常见的有损压缩。 但如果想要维持分类和搜索质量，就需要维护数量庞大的聚类中心。随之而来会带来另一个问题，那就是聚类中心点的数量会随着维度的增加而指数级增长，这样会导致我们存储码本的数量极速增加，从而极大的增加了内存的消耗。

所以, 将向量分解为多个子向量，然后对每个子向量独立进行量化，比如将 128 维的向量分为 8 个 16 维的向量，然后在 8 个 16 维的子向量上分别进行聚类

### Hierarchical Navigable Small Worlds (HNSW)

每次将向量加到数据库中的时候，就先找到与它最相邻的向量，然后将它们连接起来，这样就构成了一个图。当需要搜索的时候，就可以从图中的某个节点开始，不断的进行最相邻搜索和最短路径计算，直到找到最相似的向量。

