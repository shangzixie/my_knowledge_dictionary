# rpc一次的调用过程

因为 RPC 是远程调用，首先会涉及网络通信， 又因为 RPC 用于业务系统之间的数据交互，要保证数据传输的可靠性，所以它一般默认采用 TCP 来实现网络数据传输。

网络传输的数据必须是二进制数据，可是在 RPC 框架中，调用方请求的出入参数都是对象，对象不能直接在网络中传输，所以需要提前把对象转成可传输的二进制数据，转换算法还要可逆，这个过程就叫`序列化`和`反序列化`。

另外，在网络传输中，RPC 不会把请求参数的所有二进制数据一起发送到服务提供方机器上，而是拆分成好几个数据包（或者把好几个数据包封装成一个数据包），所以服务提供方可能一次获取多个或半个数据包，这也就是网络传输中的粘包和半包问题。为了解决这个问题，需要提前约定传输数据的格式，即`RPC 协议`。 大多数的协议会分成数据头和消息体：

数据头一般用于身份识别，包括协议标识、数据大小、请求类型、序列化类型等信息；

一次RPC调用过程如下：

1. 客户端调用： 客户端调用本地的代理（stub），就像调用本地方法一样，代理负责将方法调用转换为RPC请求。

2. 序列化： 客户端代理将方法调用参数序列化为字节流，以便在网络上传输。

3. 发送请求： 序列化后的请求通过网络发送到服务端。

4. 服务端接收请求： 服务端接收请求并反序列化为方法调用参数。

5. 方法执行： 服务端调用实际的方法并获取结果。

6. 序列化结果： 服务端将方法调用结果序列化为字节流。

7. 发送响应： 序列化后的响应通过网络发送回客户端。

8. 客户端接收响应： 客户端接收响应并反序列化为方法调用结果。

9. 返回结果： 客户端代理将结果返回给调用者。

## 支持格式

![2](/Image/rpc/2.png)

而且, json一般是string文本格式, 需要类型转换, 不同数据之间也需要逗号空格之间隔开, 占用空间大