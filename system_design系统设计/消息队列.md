# 消息队列

## 作用

系统解耦, 流量控制. 系统解耦会带来数据一致性完整性问题, 流量控制会带来消费端或生产端信息积压问题. 

## 数据完整性

如何知道有消息丢失? -> 哪些消息会丢失 -> 如何确保消息不丢失

基本阶段做下面三个事情:

![48](/Image/system_design/48.png)

但是这些在分布式事务中还不够, 本着design for failure的原则, 一定要考虑消息丢失的情况.

所以可以用一个全局唯一id, 赋给每个消息, 消费端消费完消息后, 通过这个id来确认消息是否被消费, 具体:

![48](/Image/system_design/49.png)

## 重复消费问题

![48](/Image/system_design/50.png)

最简单方法就是通过数据库:

![48](/Image/system_design/51.png)

举例, 业务操作可以放到数据库里面, 先数据库插入一条数据, 再通过数据库进行后续异步业务操作. 数据库也可以是redis. 同样得, 消息需要有一个全局唯一id

## 消息积压问题

给面试官引导, 消息积压一定是性能问题, 一般是扩容或者降级

扩容消费者实例的时候, 必须同步扩容主题topic数量, 因为是单线程

## kafaka结构

* Producer：生产者，负责将客户端生产的消息发送到 Kafka 中，可以支持消息的异步发送和批量发送；
* broker：服务代理节点，Kafka 集群中的一台服务器就是一个 broker，可以水平无限扩展，同一个 Topic 的消息可以分布在多个 broker 中；
* Consumer：消费者，通过连接到 Kafka 上来接收消息，用于相应的业务逻辑处理。
* ZooKeeper：不废话了～不认识它的可以翻下我前面发的文章，一文搞定ZooKeeper；
* Consumer Group：消费者组，指的是多个消费者共同组成一个组来消费一个 Topic 中的消息。

![48](/Image/system_design/76.png)

1）Topic 与 Partition

在 Kafka 中消息是以 Topic 为单位进行归类的，Topic 在逻辑上可以被认为是一个 Queue，Producer 生产的每一条消息都必须指定一个 Topic，然后 Consumer 会根据订阅的 Topic 到对应的 broker 上去拉取消息。

为了提升整个集群的吞吐量，Topic 在物理上还可以细分多个分区，一个分区在磁盘上对应一个文件夹。由于一个分区只属于一个主题，很多时候也会被叫做主题分区(Topic-Partition)。

2）Leader 和 Follower

一个分区会有多个副本，副本之间是一主(Leader)多从(Follower)的关系，Leader 对外提供服务，这里的对外指的是与客户端程序进行交互，而 Follower 只是被动地同步 Leader 而已，不能与外界进行交互。

当然了，你可能知道在很多其他系统中 Follower 是可以对外提供服务的，比如 MySQL 的从库是可以处理读操作的，但是在 Kafka 中 Follower 只负责消息同步，不会对外提供服务。

Kafka 为分区引入了多副本机制，同一分区的不同副本中保存的信息是相同的，通过多副本机制实现了故障的自动转移，当集群中某个 broker 失效时仍然能保证服务可用，可以提升容灾能力。
